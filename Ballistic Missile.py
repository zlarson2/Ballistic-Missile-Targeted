import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib.offsetbox import AnnotationBbox, OffsetImage
from PIL import Image, ImageDraw
import subprocess
import matplotlib.cm as cm
import matplotlib.mlab as mlab
from mpl_toolkits.mplot3d import axes3d

def Pressure(Altitude):
    """This function calculates the atmospheric pressure. The only input is the
    Altitude. The variables in the function are:
    
    Po:   Atmospheric pressure at sea level
    mol:  Amount of air in one gram
    Tsea: Temperature at sea level
    R:    Gas constant for air
    g:    Gravitational constant
    
    The function will return the calculated atmospheric pressure"""
    
    Po = 101325     #(Pa)
    mol = 0.02897   #(mol)
    Tsea  = 288     #(K)
    R = 8.314510    #(J / K mol)
    g = 9.81        #(m/s^2)
    return Po * np.exp((-mol * g * Altitude)/(R * Tsea)) #(Pa)

def Temperature(Altitude):
    """This function calculates the atmospheric temperature at any given altitude.
    The function has one input for altitude. Because atmospheric temperature can not
    be represented as one equation, this function is made up of a series of curve fits
    which each make up a section of the atmosphere. After an elevation of 120 km
    the atmosphere becomes so sparse that it become negligible so the function keeps a
    constant temperature after that point."""
    
    Altitude = Altitude/1000                                            #(km)
    if Altitude < 12.5: return 276.642857143 - 5.02285714286 * Altitude #(K)
    if Altitude < 20: return 213.0                                      #(K)
    if Altitude < 47.5: return 171.224358974 + 2.05384615385 * Altitude #(K)
    if Altitude < 52.5: return 270.0                                    #(K)
    if Altitude < 80: return 435.344405594 - 3.13916083916 * Altitude   #(K)
    if Altitude < 90: return 183.0                                      #(K)
    if Altitude < 110: return -221.111111111 + 4.47 * Altitude          #(K)
    if Altitude < 120: return -894.0 + 10.6 * Altitude                  #(K)
    if Altitude >= 120: return -894.0 + 10.6 * 120                      #(K)

def CD(M):
    """This function calculates the drag coefficient of the rocket. This function is based
    off of a plot that relates the drag coefficient with the mach number of the rocket.
    Because the plot can not be represented with one equation it is broken up into multiple
    curve fits. The only input for the function is the mach number the rocket is traveling."""
    
    if M < .5: return .125
    if M < 1.1875: return -0.329086061307 + 2.30117394072 * M + -4.06597222013 * M**2 + 3.01851851676 * M**3 + -0.666666666129 * M**4
    if M < 1.625: return 0.10937644721 + -4.61979595244 * M + 9.72917139612 * M**2 + -6.33333563852 * M**3 + 1.33333375211 * M**4
    if M < 3.625: return 0.97916002909 + -0.540978181863 * M + 0.125235817144 * M**2 + -0.00666103733277 * M**3 + -0.000558009790208 * M**4
    if M > 3.625: return .25

def ThrustFun(MassOut,Altitude,FuelArea,NozzleAltitude):
    """This function calculates the thrust force of the rocket by maximizing the efficiency
    through designing the correct shaped nozzle for the given rocket scenario. For this
    function is gives the option for stages of the rocket to be introduced. Theoretically
    this function can have an unlimited amount of stages but for this particular use there
    will only be 3 stages. The inputs for the function are:
    
    MassOut:            Mass leaving the nozzle
    Altitude:           Rockets current elevation
    FuelArea:           Burn area in the combustion chamber
    NozzleAltitude:     Altitude immediately after a rocket stage detaches
    
    The constants for the function were based off of data found for the Trident II Intercontinental
    ballistic missile. These constants are:

    k:  Specific heat ratio for the fuel
    Ru:  Universal gas constant
    Tc: Chamber temperature
    Pc: Chamber pressure
    Mw: Molecular weight of the fuel
    q:  Mass flow out through the nozzle
    Pa: Atmospheric pressure used for optimizing nozzle diameters

    The iteratively calculated variables for this function are:

    Pe: Current atmospheric pressure
    Pt: Throat pressure
    Tt: Throat temperature
    At: Throat area
    Nm: Mach number of the exiting gas
    Ae: Exit area of the nozzle
    Ve: Velocity of the fuel exiting the nozzle

    After making all of these calculations the function will return the force generated by the trust
    of the fuel in units of Newtons. This function will also make sure that the exit nozzle area will
    not exceed that of the cross sectional area for the inside of rocket casing."""
    
    k = 1.2                                                                     #Heat Ratio
    Ru = 8314.4621                                                              #Universal Gas Constant (m^3 Pa / K mol)
    Tc = 3700                                                                   #(K)
    Pc = 25*10**6                                                               #Chamber Pressure (Pa)
    Mw = 22                                                                     #Molecular Weight
    q = MassOut                                                                 #Mass Flow Rate (kg/s)
    Pa = Pressure(NozzleAltitude)                                               #Ambient pressure used to calculate nozzle (Pa)
    Pe = Pressure(Altitude)                                                     #Actual Atmospheric Pressure (Pa)
    Pt = Pc*(1 + (k - 1)/2)**(-k/(k - 1))                                       #Throat Pressure (Pa)
    Tt = Tc/(1 + (k - 1)/2)                                                     #Throat Temperature (k)
    At = (q/Pt)*np.sqrt((Ru*Tt)/(Mw*k))                                          #Throat Area (m^2)
    Nm = np.sqrt(2/(k - 1)*((Pc/Pa)**((k - 1)/k) - 1))                          #Mach Number
    Ae = (At/Nm)*((1 + ((k - 1)/2)*Nm**2)/((k + 1)/2))**((k + 1)/(2*(k - 1)))   #Exit Nozzle Area (m^2)
    if Ae > FuelArea: Ae = FuelArea
    Ve = np.sqrt(((2*k)/(k - 1))*((Ru*Tc)/Mw)*(1 - (Pe/Pc)**((k - 1)/k)))        #Partical Exit Velocity (m/s)
    return q * Ve + (Pe - Pa) * Ae                                              #Thrust (N)

def CoordinateCalculator(CurrentLatitude,CurrentLongitude,TargetLatitude,TargetLongitude):
    """This function calculates the path of the rocket across the earth in terms of coordinates by using
    great-circle equations. It will also calculate which direction will be the shortest distance to the
    target and then calculate the distance across the surface of the earth to the target. There is only
    one constant for this function and that is the radius of the earth. After finding all the variables
    for the final and initial points it will the calculate the coordinates along the path by first extending
    the line between the two points until it reaches the equator. To calculate coordinates along the path it
    needs the angle the line makes at the equator and also at what longitude the line intersects the equator.
    The inputs for this function are:

    Phi1:    Latitude coordinate of the starting point
    Lambda1: Longitude coordinate of the starting point
    Phi2:    Latitude coordinate of the ending point
    Lambda2: Longitude coordinate of the ending point

    The variables that are calculated are:

    Lambda12:     Angle difference between the starting and ending longitude coordinates
    Alpha1:       Angle from north the initial point will start its travel at
    Alpha2:       Angle from north the final point will be traveling at
    DeltaTheta12: Angle between the two initial and final coordinates
    ArcLength:    Distance along the earth between the two points
    Alphao:       Angle off of the great circle line and north when extended back to the equator.
    DeltaSigma01: Angular distance between the point at the equator and the initial point.
    DeltaSigma02: Angular distance between the point at the equator and the final point
    Lambda01:     Longitude difference between the initial point and the point at the equator
    Lambdao:      Longitude at the point where the great circle intersects the equator
    Sigma:        Arc distance between the first point and any point along the great circle.
    Phi:          Latitude at the arbitrary point on the great circle
    Lambda:       Longitude at the arbitrary point on the great circle

    This function generates 100 points along the great circle and calculates each longitude and latitude
    and then stores them in lists. Because these list will be used to plot the great circle path the
    coordinate will be broken up into multiple lists if the path passes over edge of the map. The last thing
    the function does before returning the outputs is plotting the great circle onto a map of the globe.
    The outputs are:

    The list of latitudes
    The list of longitudes
    The angle from north to start the great circle
    The angular distance between the starting and ending point"""
    
    r = EarthRadius                             #(m)
    Phi1 = CurrentLatitude * np.pi / 180        #(Rad)
    Lambda1 = CurrentLongitude * np.pi / 180    #(Rad)
    Phi2 = TargetLatitude * np.pi / 180         #(Rad)
    Lambda2 = TargetLongitude * np.pi / 180     #(Rad)
    
    if -180 <= Lambda2 - Lambda1 <= 180: Lambda12 = Lambda2 - Lambda1       #(Rad)
    if Lambda2 - Lambda1 > 180: Lambda12 = (Lambda2 - Lambda1) - 2 * np.pi  #(Rad)
    if Lambda2 - Lambda1 < -180: Lambda12 = (Lambda2 - Lambda1) + 2 * np.pi #(Rad)
    
    Alpha1 = np.arctan2(np.array(np.sin(Lambda12)),np.array(np.cos(Phi1) * np.tan(Phi2) - np.sin(Phi1) * np.cos(Lambda12)))     #(Rad)
    Alpha2 = np.arctan2(np.array(np.sin(Lambda12)),np.array(-np.cos(Phi2) * np.tan(Phi1) + np.sin(Phi2) * np.cos(Lambda12)))    #(Rad)
    DeltaTheta12 = np.arccos((np.sin(Phi1) * np.sin(Phi2) + np.cos(Phi1) * np.cos(Phi2) * np.cos(Lambda12)))                    #(Rad)
    ArcLength = DeltaTheta12 * r                                                                                                #(m)
    Alphao = np.arcsin(np.sin(Alpha1) * np.cos(Phi1))                                                                           #(Rad)
    DeltaSigma01 = np.arctan2(np.array(np.tan(Phi1)),np.array(np.cos(Alpha1)))                                                  #(Rad)
    DeltaSigma02 = DeltaSigma01 + DeltaTheta12                                                                                  #(Rad)
    Lambda01 = np.arctan2(np.array(np.sin(Alphao) * np.sin(DeltaSigma01)),np.array(np.cos(DeltaSigma01)))                       #(Rad)
    Lambdao = Lambda1 - Lambda01                                                                                                #(Rad)
    LatList = []
    LatList1 = []
    LatList2 = []
    LatList3 = []
    LongList = []
    LongList1 = []
    LongList2 = []
    LongList3 = []
    for i in range(101):
        Sigma = DeltaSigma01 + (i * (DeltaSigma02 - DeltaSigma01))/100                                                          #(Rad)
        Phi = (np.arcsin(np.cos(Alphao) * np.sin(Sigma)) * 180 / np.pi)                                                         #(Degrees)
        Lambda = (Lambdao + np.arctan2(np.array(np.sin(Alphao) * np.sin(Sigma)),np.array(np.cos(Sigma)))) * 180 / np.pi         #(Degrees)
        if -180 <= Lambda <= 180:
            LongList1.append(Lambda)        #(Degrees)
            LatList1.append(Phi)            #(Degrees)
        if Lambda > 180:
            LongList2.append(Lambda - 360)  #(Degrees)
            LatList2.append(Phi)            #(Degrees)
        if Lambda < -180:
            LongList3.append(Lambda + 360)  #(Degrees)
            LatList3.append(Phi)            #(Degrees)

    im = plt.imread('EarthCordiants.jpg')
    im = plt.imshow(im, interpolation='bilinear', cmap=cm.gray, origin='lower', extent=[-180,180,-90,90])
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.title('Path of Rocket')
    plt.plot(LongList1, LatList1, 'r')
    plt.plot(LongList2, LatList2, 'r')
    plt.plot(LongList3, LatList3, 'r')
    plt.show()
    
    LatList.append(LatList1)
    LatList.append(LatList2)
    LatList.append(LatList3)
    LongList.append(LongList1)
    LongList.append(LongList2)
    LongList.append(LongList3)
    
    return LatList, LongList, Alpha1 * 180 / np.pi, ArcLength

def RocketOrbit(OppositeList,AdjacentList):
    """This function takes the path of the rocket as it orbits the earth and plots it onto a picture of the globe.
    It will always start the path from the north end of the glob and ends on an arbitrary point which is just meant
    to represent visually the distance the missile traveled across the earth. It also helps visualize the altitude
    the rocket reaches. The inputs for this function are:

    OppositeList: x components of the rockets path
    AdjacentList: y components of the rockets path"""
    
    image = plt.imread('Earth.jpg')
    im = plt.imshow(image, interpolation='bilinear', cmap=cm.gray, origin='lower', extent=[-EarthRadius * 2.3,EarthRadius * 2.3,-EarthRadius * 2.3,EarthRadius * 2.3])
    plt.title('Path of Rocket')
    plt.plot(OppositeList, AdjacentList, 'r')
    plt.axis('off')
    plt.show()
    
def IterationFun(FuelArea, FuelMass, RocketArea, Altitude, RocketCasingMass, NozzleAltitude, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient):
    """This function is the heart of the program. It calculates the simulated flight
    of the missile. This is only one step of the flight, to get the whole flight
    simulated it must be iterated in a loop. The inputs for the function are:

    FuelArea:         Area of the fuel surface being burned
    FuelMass:         Current mass left in the rocket
    RocketArea:       Cross sectional area of the missile
    Altitude:         Current altitude of the missile
    RocketCasingMass: Mass of the casing for the missile
    NozzleAltitude:   Altitude when the casing stage detaches
    drdt:             Current velocity in the vertical direction
    dthetadt:         Current angular velocity around the earth
    Distance:         Current distance traveled by the missile
    ArcDistance:      Current distance traveled along the earths surface
    MassIn:           Current fuel mass entering the rocket (always 0)
    AngleCoefficient: The coefficient used to govern the missiles trajectory

    The outputs for this function are:

    FuelMass:    Mass left in the missile
    RocketMass:  Total Mass of the missile
    Tatm:        Atmospheric temperature
    Patm:        Atmospheric pressure
    AirDensity:  Density of the atmosphere
    c:           Current speed of sound of the atmosphere
    M:           Missiles mach number
    cD:          Missiles drag Coefficient
    Thrust:      Thrust produced by the missile
    DragForce:   Drag force acting upon the missile
    WeightForce: Gravitational attraction exerted by the earth
    dr2dt:       Acceleration in the vertical direction
    drdt:        New velocity in the vertical direction
    Altitude:    New altitude of the missile
    Distance:    New distance traveled by the missile
    ArcVelocity: Velocity of the missile across the surface of the earth
    ArcDistance: New distance traveled along the earths surface
    dtheta2dt:   Angular acceleration around the earth
    dthetadt:    New angular velocity around the earth

    Some of these values do not need to be returned for calculations in later
    iterations but are returned anyways to present the data later on in plots
    in order to understand the flight of the missile and its governing principles"""
    
    #This governs the thrust angle as a function of altitude
    if Altitude < 120000: ThrustAngle = (90 - (AngleCoefficient) * (1.5336118956 + 0.00443173537387 * Altitude - (9.30373890848 * 10**-8) * Altitude**2 + (8.37838197732 * 10**-13) * Altitude**3 - (2.71228576626 * 10**-18) * Altitude**4)) * 0.0174533 #(Degrees)
    else: ThrustAngle = 30

    #This calculates the angle the drag force acts upon the missile
    Radius = EarthRadius + Altitude                             #(m)
    DragAngle = np.arctan2(drdt,dthetadt)                       #(Degrees)

    #This calculates fuel mass vs time                             
    if FuelMass > 0:
        MassOut = FuelDensity * FuelArea * BurnRate             #(kg)
        dmdt = MassIn - MassOut                                 #(kg/s)
        FuelMass = FuelMass + dmdt * h                          #(kg)
    else:
        FuelMass = 0
    
    RocketMass =  FuelMass + RocketCasingMass + WarheadMass     #(Kg)
    Tatm = Temperature(Altitude)                                #(K)
    Patm = Pressure(Altitude)                                   #(pa)
    AirDensity = Patm/(R * Tatm)                                #(kg/m^3)

    #This calculates the drag coeficiant
    c = (1.4 * R * Tatm)**(1/2)                                 #(m/s)
    M = (np.sqrt(drdt**2 + dthetadt**2))/c                      #(Unitless)
    cD = CD(abs(M))                                             #(Unitless)

    #This calculates all the forces acting upon the missile
    if FuelMass > 0: Thrust = ThrustFun(MassOut,Altitude,FuelArea,NozzleAltitude)   #(N)
    else: Thrust = 0                                                                #(N)
    DragForce = (1/2) * AirDensity * (drdt**2 + dthetadt**2) * RocketArea * cD      #(N)
    WeightForce = (G * EarthMass * RocketMass)/(Radius)**2                          #(N)

    #Vertical Acceleration and velocity
    dr2dt = ((Thrust * np.sin(ThrustAngle) - DragForce * np.sin(DragAngle) - WeightForce) / RocketMass) + Radius * (dthetadt/Radius)**2 #(m/s^2)
    drdt = drdt + dr2dt * h                         #(m/s)

    Altitude = Altitude + drdt * h                  #(m)

    Distance = Distance + dthetadt * h              #(m)

    #Angular distance the missile traveled vs time
    ArcVelocity = (dthetadt * EarthRadius)/Radius   #(m/s)
    ArcDistance = ArcDistance + ArcVelocity * h     #(m)

    #Angular acceleration and velocity 
    dtheta2dt = (((Thrust * np.cos(ThrustAngle) - DragForce * np.cos(DragAngle)) / RocketMass) - 2 * drdt * (dthetadt/Radius))  #(m/s^2)
    dthetadt = dthetadt + dtheta2dt * h #(m/s)

    return FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt

def Bisection(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea, Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3, NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, ArcLength):
    """This function is designed to calculate the needed angle coefficient to for the trust
    to govern the missiles path into its designated target. Because this missile has the
    capability of entering into orbit, more complicated calculations needed to be used to
    insure that the program would be successful in finding the correct drag coefficient
    in all instances. How the function works is by running the missile simulation multiple
    times with different angle coefficients to find with one lands the missile closest to
    its target. Once it has a ball park region for the angle coefficient it runs a modified
    bisection method to further bring the angle coefficient closer to the needed value to
    land the missile on the target. The inputs for the program are:

    FuelArea1:         Area of the fuel surface being burned for the first and second stages of the missile
    FuelArea2:         Area of the fuel surface being burned for the third stage of the missile
    FuelMass:          Mass left in the missile
    FuelVolume:        Initial value of the total volume of fuel stored in the missile
    RocketArea:        Cross sectional area of the missile
    Altitude:          Initial condition for the altitude (0 meters)
    RocketCasingMass1: Mass of the casing for the missiles during the first stage
    RocketCasingMass2: Mass of the casing for the missiles during the second stage
    RocketCasingMass3: Mass of the casing for the missiles during the third stage
    NozzleAltitude1:   The altitude used to calculate the nozzle for the first stage (0 meters)
    drdt:              Initial condition for the velocity in the vertical direction (0 m/s)
    dthetadt:          Initial condition for the angular velocity around the earth (0 m/s)
    Distance:          Initial condition for the distance traveled by the missile (0 meters)
    ArcDistance:       Initial condition for the distance traveled along the earths surface (0 meters)
    MassIn:            Initial condition for the mass entering the missile (always 0)
    ArcLength:         Distance from the starting point to the target along the surface of the earth

    The functions output it:

    AngleCoefficient:  The angle coefficient which directs the missile directly to it's target"""

    ArcDistanceSteps = [0]
    Steps = 100
    for i in range (Steps):
        AngleCoefficient = (i * 1)/Steps + .935
        ArcDistanceSteps.append(QuickRun(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea,
                    Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3,
                    NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient
                    ))
    ArcDistanceClosest = min(ArcDistanceSteps, key=lambda x:abs(x-ArcLength))
    ArcDistanceClosePossition = [i for i,x in enumerate(ArcDistanceSteps) if x == ArcDistanceClosest]
    AngleCoefficient = (ArcDistanceClosePossition[0] * 1)/Steps + .935
    
    #bisection method
    AC1 = (ArcDistanceClosePossition[0] - 1)/Steps + .935
    AC2 = (ArcDistanceClosePossition[0] + 1)/Steps + .935
    ACNew = (AC1 + AC2)/2
    error = abs((ArcLength - QuickRun(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea,
                                      Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3,
                                      NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, ACNew)
                                      )/ArcLength)*100
    while error > .1:
        ACNew = (AC1 + AC2)/2
        error = abs((ArcLength - QuickRun(
                                        FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea,
                                        Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3,
                                        NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, ACNew)
                                         )/ArcLength)*100

        if QuickRun(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea,
                    Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3,
                    NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, ACNew
                    ) < ArcLength:
            AC2 = ACNew
        else:
            AC1 = ACNew
    AngleCoefficient = ACNew
    return AngleCoefficient

def QuickRun(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea, Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3, NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient):
    """This function calculates the entire simularion of the missiles tragectory without
    collecting any information along the way. It's purpose is for the angle cooefficeint
    optimizer to have a quick way to run the simulation and retreive the final distance
    the missile traveled along the surface of the earth. The functions inputs are:

    FuelArea1:         Area of the fuel surface being burned for the first and second stages of the missile
    FuelArea2:         Area of the fuel surface being burned for the third stage of the missile
    FuelMass:          Mass left in the missile
    FuelVolume:        Initial value of the total volume of fuel stored in the missile
    RocketArea:        Cross sectional area of the missile
    Altitude:          Initial condition for the altitude (0 meters)
    RocketCasingMass1: Mass of the casing for the missiles during the first stage
    RocketCasingMass2: Mass of the casing for the missiles during the second stage
    RocketCasingMass3: Mass of the casing for the missiles during the third stage
    NozzleAltitude1:   The altitude used to calculate the nozzle for the first stage (0 meters)
    drdt:              Initial condition for the velocity in the vertical direction (0 m/s)
    dthetadt:          Initial condition for the angular velocity around the earth (0 m/s)
    Distance:          Initial condition for the distance traveled by the missile (0 meters)
    ArcDistance:       Initial condition for the distance traveled along the earths surface (0 meters)
    MassIn:            Initial condition for the mass entering the missile (always 0)
    AngleCoefficient:  Coefficient used to govern the angle of the thrust to dirrect the missile towards its target

    The output for this function is:

    ArcDistance:       The total distance traveled by the missile along the surface of the earth"""
    
    while (FuelMass/FuelDensity)/FuelVolume > 0.4 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea1, FuelMass, RocketArea, Altitude, RocketCasingMass1, NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
        NozzleAltitude2 = Altitude
    while (FuelMass/FuelDensity)/FuelVolume > 0.19 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea1, FuelMass, RocketArea, Altitude, RocketCasingMass2, NozzleAltitude2, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
        NozzleAltitude3 = Altitude
    while (FuelMass/FuelDensity)/FuelVolume > 0 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea2, FuelMass, RocketArea, Altitude, RocketCasingMass3, NozzleAltitude3, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
    while Altitude > 0:
        FuelMass = 0
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea2, FuelMass, RocketArea, Altitude, RocketCasingMass3, NozzleAltitude3, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
    return ArcDistance

def Missile(CurrentLatitude,CurrentLongitude,TargetLatitude,TargetLongitude,NumberWarheads):
    """This is the main function for this program. It calculates and designs the flight path of an intercontinental
    ballistic missile (IBM). This function calls upon many sub-functions to help it iteratively calculate many of the
    changing variables as the rocket makes its path around the world. Changing variables that had to be taken into
    account include:

    Air density vs altitude
    Air pressure vs altitude
    Air temperature vs altitude
    Drag coefficient vs mach number
    Speed of sound vs altitude
    Drag force vs time
    Gravitational attraction vs altitude
    Fuel mass vs time
    Thrust vs time
    Vertical velocity vs time
    Angular velocity vs time
    Vertical acceleration vs time
    Angular acceleration vs time
    Angular distance rocket travels vs time
    Total distance rocket travels vs time

    Many of these variables are dependent on each other. The inputs of this function are:

    CurrentLatitude:  Latitude of the starting position
    CurrentLongitude: Longitude of the starting position
    TargetLatitude:   Latitude of the ending position
    TargetLongitude:  Longitude of the ending position
    NumberWarheads:   Number of warhead loaded onto the missile

    The coordinates are to be inputed as degrees and NumberWarheads must be an intagure. The first thing the
    program does is calculate everything regarding the path the rocket will take to minimize
    distance needed to travel. It uses the CoordinateCalculator function to accomplish this.
    It then calculates everything regarding the casing and fuel of the rocket. After calculating all
    the necessary constants it starts its iterative calculation of the rockets actual path and collects
    information into lists as it moves through its times steps. It changes its iterative approach once
    the rocket runs out of fuel by dropping out everything used to calculate the trust. Once the rocket
    reaches an altitude of zero meters it ends the iterations. Using all the information gathers it
    presents them in the form of print statements and also plots."""

    #Dimensions of the rocket
    Length = 15     #(m)
    Diameter = 3.1  #(m)
    
    if CurrentLatitude > 90 or CurrentLatitude < -90:
        print('Error: Current Latitude must be between 90 and -90 degrees')
        return
    if CurrentLongitude > 180 or CurrentLongitude < -180: 
        print('Error: Current Longitude must be between 180 and -180 degrees')
        return
    if TargetLatitude > 90 or TargetLatitude < -90: 
        print('Error: Target Latitude must be between 90 and -90 degrees')
        return 
    if TargetLongitude > 180 or TargetLongitude < -180: 
        print('Error: Target Longitude must be between 180 and -180 degrees')
        return 
    if NumberWarheads > 12: 
        print('Error: Rocket can hold up to 12 warheads')
        return 
    if not float(NumberWarheads).is_integer():  
        print('Error: The number of warheads must be a whole number')
        return
    
    global EarthRadius, EarthMass, FuelDensity, BurnRate, WarheadMass, R, G, h
    
    EarthRadius = 6371000       #(m)
    R = 287                     #(J * K^-1 * kg^-1)
    G = 6.67384 * 10**-11       #(m^3 * kg^-1 * s^-2)
    EarthMass = 5.9726 * 10**24 #(kg)

    #This function will calculate the path the rocket will take in terms of coordinates
    LatList, LongList, Alpha1, ArcLength = CoordinateCalculator(CurrentLatitude,CurrentLongitude,TargetLatitude,TargetLongitude)

    if ArcLength < 320000: 
        print('Error: This missile has a minimum distance of 320 km. \n       Please chose different target coordinates.')
        return
    #Calculations for the warheads
    WarheadMass = 320 * NumberWarheads                  #(Kg)
    WarheadPayload = 475 * NumberWarheads               #(KiloTons of TNT)
    TotalDestruction = 92.721574 * NumberWarheads       #(km^2)
    PartialDestruction = 261.5888 * NumberWarheads      #(km^2)

    #Calculations for the casing
    Thickness = 0.050389573 * Diameter                                                      #(m)    
    RocketArea = .25 * math.pi * Diameter**2                                                #(m^2)
    RocketVolume = (RocketArea) * Length                                                    #(m^3)
    RocketCasingDensity = 1628.75                                                           #(kg/m^3)http://scholar.lib.vt.edu/theses/available/etd-101198-161441/unrestricted/appendix.pdf
    RocketCasingVolume = .25 * math.pi * Length * (Diameter**2 - (Diameter - Thickness)**2) #(m^3)
    RocketCasingMass1 = RocketCasingDensity * RocketCasingVolume                                                                 #(kg)
    RocketCasingMass2 = RocketCasingDensity*.25*math.pi*(Length*0.4937)*(Diameter**2-(Diameter-Thickness)**2)                    #(kg)
    RocketCasingMass3 =  RocketCasingDensity*.25*math.pi*(Length*0.157)*((Diameter*.75)**2-((Diameter*.75)-(Thickness)/2)**2)    #(kg)

    #Calculations for the fuel
    BurnRate = .042                                                         #(m/s)
    FuelDensity = 1750                                                      #(kg/m^2)
    FuelArea1 = .25 * math.pi * (Diameter - Thickness)**2                   #(m^2)
    FuelArea2 = .25 * math.pi * ((Diameter * .75) - Thickness)**2           #(m^2)
    FuelVolume = FuelArea1 * (Length*0.651) + FuelArea2 * (Length*0.178)    #(m^3)
    FuelMass = FuelDensity * FuelVolume                                     #http://www.lr.tudelft.nl/en/organisation/departments/space-engineering/space-systems-engineering/expertise-areas/space-propulsion/design-of-elements/rocket-propellants/solids/
    RocketMass =  FuelMass + RocketCasingMass1 + WarheadMass                #(kg)

    #Here are the initial conditions
    dthetadt = 0.001    #(m/s)
    drdt = 0.001        #(m/s)
    Altitude = 0        #(m)
    NozzleAltitude1 = 0 #(m)
    Distance = 0        #(m)       
    ArcDistance = 0     #(m)
    MassIn = 0          #(kg/s)
    
    #Here are the time steps and counters
    y = 0
    z = 0
    t = 0
    h = 1

    #Here are the definitions for all the lists
    OppositeList = []
    AdjacentList = []
    WeightForceList = []
    AltitudeList = []
    DistanceList = []
    ArcDistanceList = []
    drdtList = []
    dthetadtList = []
    MList = []
    FuelMassList = []
    hList = []
    ThrustList = []
    NozzleAltitude = np.arange(0,100000,1)
    ExitcDList = []
    Exitdr2dtList = []
    Exitdtheta2dtList = []
    ExitDragForceList = []
    ExitcList = []
    ExitAirDensityList = []
    ExitPatmList = []
    ExitTatmList = []
    EntercDList = []
    Enterdr2dtList = []
    Enterdtheta2dtList = []
    EnterDragForceList = []
    EnterAirDensityList = []
    EnterPatmList = []
    EnterTatmList = []
    EntercList = []
    TotalDistanceList = []    

    AngleCoefficient = Bisection(FuelArea1, FuelArea2, FuelMass, FuelVolume, RocketArea, Altitude, RocketCasingMass1, RocketCasingMass2, RocketCasingMass3, NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, ArcLength)
    
    while (FuelMass/FuelDensity)/FuelVolume > 0.4 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea1, FuelMass, RocketArea, Altitude, RocketCasingMass1, NozzleAltitude1, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
        NozzleAltitude2 = Altitude

        AdjacentList.append(math.cos(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        OppositeList.append(math.sin(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        WeightForceList.append(WeightForce/RocketMass)
        ThrustList.append(Thrust/1000)
        MList.append(M)
        AltitudeList.append(Altitude/1000)
        DistanceList.append(Distance/1000)
        ArcDistanceList.append(ArcDistance/1000)
        drdtList.append(drdt)
        dthetadtList.append(dthetadt)
        hList.append(h + sum(hList))
        Exitdr2dtList.append(dr2dt)
        Exitdtheta2dtList.append(dtheta2dt)
        if Altitude < 120000: ExitDragForceList.append(DragForce/1000)
        if Altitude < 100000: ExitcList.append(c)
        if Altitude < 120000: ExitAirDensityList.append(AirDensity)
        if Altitude < 120000: ExitPatmList.append(Patm/101325)
        if Altitude < 100000: ExitTatmList.append(Tatm)
        if Altitude < 100000: ExitcDList.append(cD)
        if FuelMass > 0: FuelMassList.append(FuelMass)
        t += 1
    FirstStageTime = t
    
    while (FuelMass/FuelDensity)/FuelVolume > 0.19 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea1, FuelMass, RocketArea, Altitude, RocketCasingMass2, NozzleAltitude2, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)
        NozzleAltitude3 = Altitude

        AdjacentList.append(math.cos(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        OppositeList.append(math.sin(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        WeightForceList.append(WeightForce/RocketMass)
        ThrustList.append(Thrust/1000)
        MList.append(M)
        AltitudeList.append(Altitude/1000)
        DistanceList.append(Distance/1000)
        ArcDistanceList.append(ArcDistance/1000)
        drdtList.append(drdt)
        dthetadtList.append(dthetadt)
        hList.append(h + sum(hList))
        Exitdr2dtList.append(dr2dt)
        Exitdtheta2dtList.append(dtheta2dt)
        if Altitude < 120000: ExitDragForceList.append(DragForce/1000)
        if Altitude < 100000: ExitcList.append(c)
        if Altitude < 120000: ExitAirDensityList.append(AirDensity)
        if Altitude < 120000: ExitPatmList.append(Patm/101325)
        if Altitude < 100000: ExitTatmList.append(Tatm)
        if Altitude < 100000: ExitcDList.append(cD)
        if FuelMass > 0: FuelMassList.append(FuelMass)
        t += 1
    SecondStageTime = t
    
    while (FuelMass/FuelDensity)/FuelVolume > 0 and Altitude >= 0:
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea2, FuelMass, RocketArea, Altitude, RocketCasingMass3, NozzleAltitude3, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)

        AdjacentList.append(math.cos(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        OppositeList.append(math.sin(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        WeightForceList.append(WeightForce/RocketMass)
        ThrustList.append(Thrust/1000)
        MList.append(M)
        AltitudeList.append(Altitude/1000)
        DistanceList.append(Distance/1000)
        ArcDistanceList.append(ArcDistance/1000)
        drdtList.append(drdt)
        dthetadtList.append(dthetadt)
        hList.append(h + sum(hList))
        Exitdr2dtList.append(dr2dt)
        Exitdtheta2dtList.append(dtheta2dt)
        if Altitude < 120000: ExitDragForceList.append(DragForce/1000)
        if Altitude < 100000: ExitcList.append(c)
        if Altitude < 120000: ExitAirDensityList.append(AirDensity)
        if Altitude < 120000: ExitPatmList.append(Patm/101325)
        if Altitude < 100000: ExitTatmList.append(Tatm)
        if Altitude < 100000: ExitcDList.append(cD)
        if FuelMass > 0: FuelMassList.append(FuelMass)
        t += 1
    ThirdStageTime = t
    
    while Altitude > 0:
        FuelMass = 0
        FuelMass, RocketMass, Tatm, Patm, AirDensity, c, M, cD, Thrust, DragForce, WeightForce, dr2dt, drdt, Altitude, Distance, ArcVelocity, ArcDistance, dtheta2dt, dthetadt = IterationFun(
            FuelArea2, FuelMass, RocketArea, Altitude, RocketCasingMass3, NozzleAltitude3, drdt, dthetadt, Distance, ArcDistance, MassIn, AngleCoefficient)

        AdjacentList.append(math.cos(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        OppositeList.append(math.sin(ArcDistance/EarthRadius) * (Altitude + EarthRadius))
        WeightForceList.append(WeightForce/RocketMass)
        MList.append(M)
        AltitudeList.append(Altitude/1000)
        DistanceList.append(Distance/1000)
        ArcDistanceList.append(ArcDistance/1000)
        drdtList.append(drdt)
        dthetadtList.append(dthetadt)
        if Altitude < 120000: EnterDragForceList.append(DragForce/1000)
        if Altitude < 120000: EntercList.append(c)
        if Altitude < 120000: EnterAirDensityList.append(AirDensity)
        if Altitude < 120000: EnterPatmList.append(Patm/101325)
        if Altitude < 120000: EnterTatmList.append(Tatm)
        if Altitude < 120000: Enterdr2dtList.append(dr2dt)
        if Altitude < 120000: Enterdtheta2dtList.append(dtheta2dt)
        if Altitude < 120000: EntercDList.append(cD)
            
    #This will find the max acceleration, max velocity, and max height out of their lists
    MaxVerticalAcceleration = max(Exitdr2dtList)
    MaxAngularAcceleration = max(Exitdtheta2dtList)
    MaxVerticalVelocity = max(drdtList)
    MaxAngularVelocity = max(dthetadtList)
    MaxAltitude = max(AltitudeList)

    MaxAltitudePossition = [i for i,x in enumerate(AltitudeList) if x == MaxAltitude]
    MaxVerticalVelocityPossition = [i for i,x in enumerate(drdtList) if x == MaxVerticalVelocity]
    MaxAngularVelocityPossition = [i for i,x in enumerate(dthetadtList) if x == MaxAngularVelocity]
    MaxVerticalAccelerationPossition = [i for i,x in enumerate(Exitdr2dtList) if x == MaxVerticalAcceleration]
    MaxAngularAccelerationPossition = [i for i,x in enumerate(Exitdtheta2dtList) if x == MaxAngularAcceleration]
    
    #This will print the variables at their max value with its respective time in minutes
    #It takes into acount the difference in the singular and plural form of the words 'minutes' and 'seconds'
    print ('ArcDistance = ',round(ArcDistance/1000,(2)),'Km')
    print ('Distance to target is',round(ArcLength/1000,(2)),'km','\nDirection to target is',round(Alpha1,(2)),' degrees from north')
    if math.floor((MaxAltitudePossition[0] * h)/60) == 1 and math.floor((MaxAltitudePossition[0] * h)%60) == 1: print ('Max Altitude is',round(MaxAltitude,(2)),'kilometers at',math.floor((MaxAltitudePossition[0] * h)/60),'minute',math.floor((MaxAltitudePossition[0] * h)%60),'second')
    elif math.floor((MaxAltitudePossition[0] * h)/60) == 1 and math.floor((MaxAltitudePossition[0] * h)%60) != 1: print ('Max Altitude is',round(MaxAltitude,(2)),'kilometers at',math.floor((MaxAltitudePossition[0] * h)/60),'minute',math.floor((MaxAltitudePossition[0] * h)%60),'seconds')
    elif math.floor((MaxAltitudePossition[0] * h)/60) != 1 and math.floor((MaxAltitudePossition[0] * h)%60) == 1: print ('Max Altitude is',round(MaxAltitude,(2)),'kilometers at',math.floor((MaxAltitudePossition[0] * h)/60),'minutes',math.floor((MaxAltitudePossition[0] * h)%60),'second')
    else: print ('Max Altitude is',round(MaxAltitude,(2)),'kilometers at',math.floor((MaxAltitudePossition[0] * h)/60),'minutes',math.floor((MaxAltitudePossition[0] * h)%60),'seconds')
    if math.floor((MaxVerticalVelocityPossition[0] * h)/60) == 1 and math.floor((MaxVerticalVelocityPossition[0] * h)%60) == 1: print ('Max Vertical Velocity is',round(MaxVerticalVelocity,(2)),'m/s at',math.floor((MaxVerticalVelocityPossition[0] * h)/60),'minute',math.floor((MaxVerticalVelocityPossition[0] * h)%60),'second')
    elif math.floor((MaxVerticalVelocityPossition[0] * h)/60) == 1 and math.floor((MaxVerticalVelocityPossition[0] * h)%60) != 1: print ('Max Vertical Velocity is',round(MaxVerticalVelocity,(2)),'m/s at',math.floor((MaxVerticalVelocityPossition[0] * h)/60),'minute',math.floor((MaxVerticalVelocityPossition[0] * h)%60),'seconds')
    elif math.floor((MaxVerticalVelocityPossition[0] * h)/60) != 1 and math.floor((MaxVerticalVelocityPossition[0] * h)%60) == 1: print ('Max Vertical Velocity is',round(MaxVerticalVelocity,(2)),'m/s at',math.floor((MaxVerticalVelocityPossition[0] * h)/60),'minutes',math.floor((MaxVerticalVelocityPossition[0] * h)%60),'second')
    else: print ('Max Vertical Velocity is',round(MaxVerticalVelocity,(2)),'m/s at',math.floor((MaxVerticalVelocityPossition[0] * h)/60),'minutes',math.floor((MaxVerticalVelocityPossition[0] * h)%60),'seconds')
    if math.floor((MaxAngularVelocityPossition[0] * h)/60) == 1 and math.floor((MaxAngularVelocityPossition[0] * h)%60) == 1: print ('Max Angular Velocity is',round(MaxAngularVelocity,(2)),'m/s at',math.floor((MaxAngularVelocityPossition[0] * h)/60),'minute',math.floor((MaxAngularVelocityPossition[0] * h)%60),'second')
    elif math.floor((MaxAngularVelocityPossition[0] * h)/60) == 1 and math.floor((MaxAngularVelocityPossition[0] * h)%60) != 1: print ('Max Angular Velocity is',round(MaxAngularVelocity,(2)),'m/s at',math.floor((MaxAngularVelocityPossition[0] * h)/60),'minute',math.floor((MaxAngularVelocityPossition[0] * h)%60),'seconds')
    elif math.floor((MaxAngularVelocityPossition[0] * h)/60) != 1 and math.floor((MaxAngularVelocityPossition[0] * h)%60) == 1: print ('Max Angular Velocity is',round(MaxAngularVelocity,(2)),'m/s at',math.floor((MaxAngularVelocityPossition[0] * h)/60),'minutes',math.floor((MaxAngularVelocityPossition[0] * h)%60),'second')
    else: print ('Max Angular Velocity is',round(MaxAngularVelocity,(2)),'m/s at',math.floor((MaxAngularVelocityPossition[0] * h)/60),'minutes',math.floor((MaxAngularVelocityPossition[0] * h)%60),'seconds')
    if math.floor((MaxVerticalAccelerationPossition[0] * h)/60) == 1 and math.floor((MaxVerticalAccelerationPossition[0] * h)%60) == 1: print ('Max Vertical Acceleration is',round(MaxVerticalAcceleration,(2)),'m/s^2 at',math.floor((MaxVerticalAccelerationPossition[0] * h)/60),'minute',math.floor((MaxVerticalAccelerationPossition[0] * h)%60),'second')
    elif math.floor((MaxVerticalAccelerationPossition[0] * h)/60) == 1 and math.floor((MaxVerticalAccelerationPossition[0] * h)%60) != 1: print ('Max Vertical Acceleration is',round(MaxVerticalAcceleration,(2)),'m/s^2 at',math.floor((MaxVerticalAccelerationPossition[0] * h)/60),'minute',math.floor((MaxVerticalAccelerationPossition[0] * h)%60),'seconds')
    elif math.floor((MaxVerticalAccelerationPossition[0] * h)/60) != 1 and math.floor((MaxVerticalAccelerationPossition[0] * h)%60) == 1: print ('Max Vertical Acceleration is',round(MaxVerticalAcceleration,(2)),'m/s^2 at',math.floor((MaxVerticalAccelerationPossition[0] * h)/60),'minutes',math.floor((MaxVerticalAccelerationPossition[0] * h)%60),'second')
    else: print ('Max Vertical Acceleration is',round(MaxVerticalAcceleration,(2)),'m/s^2 at',math.floor((MaxVerticalAccelerationPossition[0] * h)/60),'minutes',math.floor((MaxVerticalAccelerationPossition[0] * h)%60),'seconds')
    if math.floor((MaxAngularAccelerationPossition[0] * h)/60) == 1 and math.floor((MaxAngularAccelerationPossition[0] * h)%60) == 1: print ('Max Angular Acceleration is',round(MaxAngularAcceleration,(2)),'m/s^2 at',math.floor((MaxAngularAccelerationPossition[0] * h)/60),'minute',math.floor((MaxAngularAccelerationPossition[0] * h)%60),'second')
    elif math.floor((MaxAngularAccelerationPossition[0] * h)/60) == 1 and math.floor((MaxAngularAccelerationPossition[0] * h)%60) != 1:print ('Max Angular Acceleration is',round(MaxAngularAcceleration,(2)),'m/s^2 at',math.floor((MaxAngularAccelerationPossition[0] * h)/60),'minute',math.floor((MaxAngularAccelerationPossition[0] * h)%60),'seconds')
    elif math.floor((MaxAngularAccelerationPossition[0] * h)/60) != 1 and math.floor((MaxAngularAccelerationPossition[0] * h)%60) == 1: print ('Max Angular Acceleration is',round(MaxAngularAcceleration,(2)),'m/s^2 at',math.floor((MaxAngularAccelerationPossition[0] * h)/60),'minutes',math.floor((MaxAngularAccelerationPossition[0] * h)%60),'second')
    else: print ('Max Angular Acceleration is',round(MaxAngularAcceleration,(2)),'m/s^2 at',math.floor((MaxAngularAccelerationPossition[0] * h)/60),'minutes',math.floor((MaxAngularAccelerationPossition[0] * h)%60),'seconds')
    if math.floor((FirstStageTime * h)/60) == 1 and math.floor((FirstStageTime * h)%60) == 1: print ('First Stage Casing ejected at',math.floor((FirstStageTime * h)/60),'minute',math.floor((FirstStageTime * h)%60),'second')
    elif math.floor((FirstStageTime * h)/60) == 1 and math.floor((FirstStageTime * h)%60) != 1: print ('First Stage Casing ejected at',math.floor((FirstStageTime * h)/60),'minute',math.floor((FirstStageTime * h)%60),'seconds')
    elif math.floor((FirstStageTime * h)/60) != 1 and math.floor((FirstStageTime * h)%60) == 1: print ('First Stage Casing ejected at',math.floor((FirstStageTime * h)/60),'minutes',math.floor((FirstStageTime * h)%60),'second')
    else: print ('First Stage Casing ejected at',math.floor((FirstStageTime * h)/60),'minutes',math.floor((FirstStageTime * h)%60),'seconds')
    if math.floor((SecondStageTime * h)/60) == 1 and math.floor((SecondStageTime * h)%60) == 1: print ('Second Stage Casing ejected at',math.floor((SecondStageTime * h)/60),'minute',math.floor((SecondStageTime * h)%60),'second')
    elif math.floor((SecondStageTime * h)/60) == 1 and math.floor((SecondStageTime * h)%60) != 1: print ('Second Stage Casing ejected at',math.floor((SecondStageTime * h)/60),'minute',math.floor((SecondStageTime * h)%60),'seconds')
    elif math.floor((SecondStageTime * h)/60) != 1 and math.floor((SecondStageTime * h)%60) == 1: print ('Second Stage Casing ejected at',math.floor((SecondStageTime * h)/60),'minutes',math.floor((SecondStageTime * h)%60),'second')
    else: print ('Second Stage Casing ejected at',math.floor((SecondStageTime * h)/60),'minutes',math.floor((SecondStageTime * h)%60),'seconds')
    if math.floor((ThirdStageTime * h)/60) == 1 and math.floor((ThirdStageTime * h)%60) == 1: print ('Third stage fuel empty at',math.floor((ThirdStageTime * h)/60),'minute',math.floor((ThirdStageTime * h)%60),'second')
    elif math.floor((ThirdStageTime * h)/60) == 1 and math.floor((ThirdStageTime * h)%60) != 1: print ('Third stage fuel empty at',math.floor((ThirdStageTime * h)/60),'minute',math.floor((ThirdStageTime * h)%60),'seconds')
    elif math.floor((ThirdStageTime * h)/60) != 1 and math.floor((ThirdStageTime * h)%60) == 1: print ('Third stage fuel empty at',math.floor((ThirdStageTime * h)/60),'minutes',math.floor((ThirdStageTime * h)%60),'second')
    else: print ('Third stage fuel empty at',math.floor((ThirdStageTime * h)/60),'minutes',math.floor((ThirdStageTime * h)%60),'seconds')
    if math.floor((len (AltitudeList) * h)/60) == 1 and math.floor((len (AltitudeList) * h)%60 == 1): print ('Impact at',math.floor((len (AltitudeList) * h)/60),'minute',math.floor((len (AltitudeList) * h)%60),'second')
    elif math.floor((len (AltitudeList) * h)/60) == 1 and math.floor((len (AltitudeList) * h)%60 != 1): print ('Impact at',math.floor((len (AltitudeList) * h)/60),'minute',math.floor((len (AltitudeList) * h)%60),'seconds')
    elif math.floor((len (AltitudeList) * h)/60) != 1 and math.floor((len (AltitudeList) * h)%60 == 1): print ('Impact at',math.floor((len (AltitudeList) * h)/60),'minutes',math.floor((len (AltitudeList) * h)%60),'second')
    else: print ('Impact at',math.floor((len (AltitudeList) * h)/60),'minutes',math.floor((len (AltitudeList) * h)%60),'seconds')
    print ('Warhead payload delivered:',WarheadPayload,'Kilotons of TNT')
    print ('Total Blast area for complete structural destruction:',round(TotalDestruction,(2)),'Square Kilometers')
    print ('Total Blast area for partial structural destruction:',round(PartialDestruction,(2)),'Square Kilometers')
    
    #These are x values for the plots
    aArray = np.arange(0,(len (AltitudeList)/h),h)
    bArray = np.arange(0,(len (ThrustList)/h),h)
    cArray = np.arange(0,(len (ExitAirDensityList)/h),h)
    dArray = np.arange((len (AltitudeList) - len (EnterAirDensityList))/h,len (AltitudeList)/h,h)
    eArray = np.arange(0,(len (ExitPatmList)/h),h)
    fArray = np.arange((len (AltitudeList) - len (EnterPatmList))/h,(len (AltitudeList)/h),h)
    gArray = np.arange(0,(len (ExitTatmList)/h),h)
    hArray = np.arange((len (AltitudeList) - len (EnterTatmList))/h,(len (AltitudeList)/h),h)
    iArray = np.arange(0,(len (ExitcList)/h),h)
    jArray = np.arange((len (AltitudeList) - len (EntercList))/h,len (AltitudeList)/h,h)
    kArray = np.arange(0,(len (ExitDragForceList)/h),h)
    lArray = np.arange((len (AltitudeList) - len (EnterDragForceList))/h,len (AltitudeList)/h,h)
    mArray = np.arange(0,(len (Exitdr2dtList)/h),h)
    nArray = np.arange((len (AltitudeList) - len (Enterdr2dtList))/h,len (AltitudeList)/h,h)
    oArray = np.arange(0,(len (FuelMassList)/h),h)
    pArray = np.arange(0,(len (ExitcDList)/h),h)
    qArray = np.arange((len (AltitudeList) - len (EntercDList))/h,len (AltitudeList)/h,h)

    #This plots the path of the rocket onto an image of the earth
    RocketOrbit(OppositeList,AdjacentList)

    #Thse are plots for a wide variety of information from each iteration
    plt.figure(1)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Distance (km)')
    plt.title('Distance along earth vs. Time')
    plt.plot(aArray, ArcDistanceList, 'k')
    
    plt.figure(2)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Distance (km)')
    plt.title('Distance Rocket Traveled vs. Time')
    plt.plot(aArray, DistanceList, 'k')
    
    plt.figure(3)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Acceleration (m/s^2)')
    plt.title('Gravitational Acceleration vs. Time')
    plt.plot(aArray, WeightForceList, 'k')
    
    plt.figure(4)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Force (kN)')
    plt.title('Thrust vs. Time')
    plt.plot(bArray, ThrustList, 'k')
    
    plt.figure(5)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('cD')
    plt.title('Re-Entry Drag Coefficient vs. Time')
    plt.plot(qArray, EntercDList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('cD')
    plt.title('Takeoff Drag Coefficient vs. Time')
    plt.plot(pArray, ExitcDList, 'k')
    
    plt.figure(6)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Force (kN)')
    plt.title('Re-Entry Drag Force vs. Time')
    plt.plot(lArray, EnterDragForceList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Force (kN)')
    plt.title('Takeoff Drag Force vs. Time')
    plt.plot(kArray, ExitDragForceList, 'k')
    
    plt.figure(7)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('M (V/c)')
    plt.title('Rocket Mach Number vs. Time')
    plt.plot(aArray, MList, 'k')

    plt.figure(8)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('c (m/s)')
    plt.title('Re-Entry Speed of Sound vs. Time')
    plt.plot(jArray, EntercList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('c (m/s)')
    plt.title('Takeoff Speed of Sound vs. Time')
    plt.plot(iArray, ExitcList, 'k')
    
    plt.figure(9)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Density (kg/m^3)')
    plt.title('Re-Entry Air Density vs. Time')
    plt.plot(dArray, EnterAirDensityList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Density (kg/m^3)')
    plt.title('Takeoff Air Density vs. Time')
    plt.plot(cArray, ExitAirDensityList, 'k')
    
    plt.figure(10)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Pressure (atm)')
    plt.title('Re-Entry Atm Pressure vs. Time')
    plt.plot(fArray, EnterPatmList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Pressure (atm)')
    plt.title('Takeoff Atm Pressure vs. Time')
    plt.plot(eArray, ExitPatmList, 'k')
    
    plt.figure(11)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Temperature (K)')
    plt.title('Re-Entry Atm Temp vs. Time')
    plt.plot(hArray, EnterTatmList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Temperature (K)')
    plt.title('Takeoff Atm Temp vs. Time')
    plt.plot(gArray, ExitTatmList, 'k')
    
    plt.figure(12)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Fuel Mass (kg)')
    plt.title('Mass of Fuel vs. Time')
    plt.plot(oArray, FuelMassList, 'k')
    
    plt.figure(13)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Acceleration (m/s^2)')
    plt.title('Re-Entry Angular ACCL vs. Time')
    plt.plot(nArray, Enterdtheta2dtList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Acceleration (m/s^2)')
    plt.title('Takeoff Angular ACCL vs. Time')
    plt.plot(mArray, Exitdtheta2dtList, 'k')
    
    plt.figure(14)       
    plt.subplot2grid((10,10),(0,6),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Acceleration (m/s^2)')
    plt.title('Re-Entry Vertical ACCL vs. Time')
    plt.plot(nArray, Enterdr2dtList, 'k')
    plt.subplot2grid((10,10),(0,0),colspan = 5,rowspan = 10)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Acceleration (m/s^2)')
    plt.title('Takeoff Vertical ACCL vs. Time')
    plt.plot(mArray, Exitdr2dtList, 'k')

    plt.figure(15)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Velocity (m/s)')
    plt.title('Rocket Angular Velocity vs. Time')
    plt.plot(aArray, dthetadtList , 'k')
    
    plt.figure(16)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Velocity (m/s)')
    plt.title('Rocket Vertical Velocity vs. Time')
    plt.plot(aArray, drdtList , 'k')
    
    plt.figure(17)
    plt.xlabel('Time (Seconds)')
    plt.ylabel('Altitude (km)')
    plt.title('Rocket Altitude vs. Time')
    plt.plot(aArray, AltitudeList, 'k')
    plt.show()
